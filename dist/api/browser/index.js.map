{
  "version": 3,
  "sources": ["../../../src/browser/node_modules/rpc-anywhere/dist/esm/rpc.js", "../../../src/browser/node_modules/rpc-anywhere/dist/esm/create-rpc.js", "../../../src/browser/webviewtag.ts", "../../../src/browser/stylesAndElements.ts", "../../../src/browser/index.ts", "../../../src/browser/index.ts"],
  "sourcesContent": [
    "const MAX_ID = 1e10;\nconst DEFAULT_MAX_REQUEST_TIME = 1000;\nfunction missingTransportMethodError(methods, action) {\n    const methodsString = methods.map((method) => `\"${method}\"`).join(\", \");\n    return new Error(`This RPC instance cannot ${action} because the transport did not provide one or more of these methods: ${methodsString}`);\n}\nexport function _createRPC(\n/**\n * The options that will be used to configure the RPC instance.\n */\noptions = {}) {\n    // setters\n    // -------\n    let debugHooks = {};\n    /**\n     * Sets the debug hooks that will be used to debug the RPC instance.\n     */\n    function _setDebugHooks(newDebugHooks) {\n        debugHooks = newDebugHooks;\n    }\n    let transport = {};\n    /**\n     * Sets the transport that will be used to send and receive requests,\n     * responses and messages.\n     */\n    function setTransport(newTransport) {\n        if (transport.unregisterHandler)\n            transport.unregisterHandler();\n        transport = newTransport;\n        transport.registerHandler?.(handler);\n    }\n    let requestHandler = undefined;\n    /**\n     * Sets the function that will be used to handle requests from the\n     * remote RPC instance.\n     */\n    function setRequestHandler(\n    /**\n     * The function that will be set as the \"request handler\" function.\n     */\n    handler) {\n        if (typeof handler === \"function\") {\n            requestHandler = handler;\n            return;\n        }\n        requestHandler = (method, params) => {\n            const handlerFn = handler[method];\n            if (handlerFn)\n                return handlerFn(params);\n            const fallbackHandler = handler._;\n            if (!fallbackHandler)\n                throw new Error(`The requested method has no handler: ${method}`);\n            return fallbackHandler(method, params);\n        };\n    }\n    // options\n    // -------\n    const { maxRequestTime = DEFAULT_MAX_REQUEST_TIME } = options;\n    if (options.transport)\n        setTransport(options.transport);\n    if (options.requestHandler)\n        setRequestHandler(options.requestHandler);\n    if (options._debugHooks)\n        _setDebugHooks(options._debugHooks);\n    // requests\n    // --------\n    let lastRequestId = 0;\n    function getRequestId() {\n        if (lastRequestId <= MAX_ID)\n            return ++lastRequestId;\n        return (lastRequestId = 0);\n    }\n    const requestListeners = new Map();\n    const requestTimeouts = new Map();\n    /**\n     * Sends a request to the remote RPC endpoint and returns a promise\n     * with the response.\n     */\n    function requestFn(method, ...args) {\n        const params = args[0];\n        return new Promise((resolve, reject) => {\n            if (!transport.send)\n                throw missingTransportMethodError([\"send\"], \"make requests\");\n            const requestId = getRequestId();\n            const request = {\n                type: \"request\",\n                id: requestId,\n                method,\n                params,\n            };\n            requestListeners.set(requestId, { resolve, reject });\n            if (maxRequestTime !== Infinity)\n                requestTimeouts.set(requestId, setTimeout(() => {\n                    requestTimeouts.delete(requestId);\n                    reject(new Error(\"RPC request timed out.\"));\n                }, maxRequestTime));\n            debugHooks.onSend?.(request);\n            transport.send(request);\n        });\n    }\n    /**\n     * Sends a request to the remote RPC endpoint and returns a promise\n     * with the response.\n     *\n     * It can also be used as a proxy to send requests by using the request\n     * name as a property name.\n     *\n     * @example\n     *\n     * ```js\n     * await rpc.request(\"methodName\", { param: \"value\" });\n     * // or\n     * await rpc.request.methodName({ param: \"value\" });\n     * ```\n     */\n    const request = new Proxy(requestFn, {\n        get: (target, prop, receiver) => {\n            if (prop in target)\n                return Reflect.get(target, prop, receiver);\n            // @ts-expect-error Not very important.\n            return (params) => requestFn(prop, params);\n        },\n    });\n    const requestProxy = request;\n    // messages\n    // --------\n    function sendFn(\n    /**\n     * The name of the message to send.\n     */\n    message, ...args) {\n        const payload = args[0];\n        if (!transport.send)\n            throw missingTransportMethodError([\"send\"], \"send messages\");\n        const rpcMessage = {\n            type: \"message\",\n            id: message,\n            payload,\n        };\n        debugHooks.onSend?.(rpcMessage);\n        transport.send(rpcMessage);\n    }\n    /**\n     * Sends a message to the remote RPC endpoint.\n     *\n     * It can also be used as a proxy to send messages by using the message\n     * name as a property name.\n     *\n     * @example\n     *\n     * ```js\n     * rpc.send(\"messageName\", { content: \"value\" });\n     * // or\n     * rpc.send.messageName({ content: \"value\" });\n     * ```\n     */\n    const send = new Proxy(sendFn, {\n        get: (target, prop, receiver) => {\n            if (prop in target)\n                return Reflect.get(target, prop, receiver);\n            // @ts-expect-error Not very important.\n            return (payload) => sendFn(prop, payload);\n        },\n    });\n    const sendProxy = send;\n    const messageListeners = new Map();\n    const wildcardMessageListeners = new Set();\n    /**\n     * Adds a listener for a message (or all if \"*\" is used) from the\n     * remote RPC endpoint.\n     */\n    function addMessageListener(\n    /**\n     * The name of the message to listen to. Use \"*\" to listen to all\n     * messages.\n     */\n    message, \n    /**\n     * The function that will be called when a message is received.\n     */\n    listener) {\n        if (!transport.registerHandler)\n            throw missingTransportMethodError([\"registerHandler\"], \"register message listeners\");\n        if (message === \"*\") {\n            wildcardMessageListeners.add(listener);\n            return;\n        }\n        if (!messageListeners.has(message))\n            messageListeners.set(message, new Set());\n        messageListeners.get(message)?.add(listener);\n    }\n    /**\n     * Removes a listener for a message (or all if \"*\" is used) from the\n     * remote RPC endpoint.\n     */\n    function removeMessageListener(\n    /**\n     * The name of the message to remove the listener for. Use \"*\" to\n     * remove a listener for all messages.\n     */\n    message, \n    /**\n     * The listener function that will be removed.\n     */\n    listener) {\n        if (message === \"*\") {\n            wildcardMessageListeners.delete(listener);\n            return;\n        }\n        messageListeners.get(message)?.delete(listener);\n        if (messageListeners.get(message)?.size === 0)\n            messageListeners.delete(message);\n    }\n    // message handling\n    // ----------------\n    async function handler(message) {\n        debugHooks.onReceive?.(message);\n        if (!(\"type\" in message))\n            throw new Error(\"Message does not contain a type.\");\n        if (message.type === \"request\") {\n            if (!transport.send || !requestHandler)\n                throw missingTransportMethodError([\"send\", \"requestHandler\"], \"handle requests\");\n            const { id, method, params } = message;\n            let response;\n            try {\n                response = {\n                    type: \"response\",\n                    id,\n                    success: true,\n                    payload: await requestHandler(method, params),\n                };\n            }\n            catch (error) {\n                if (!(error instanceof Error))\n                    throw error;\n                response = {\n                    type: \"response\",\n                    id,\n                    success: false,\n                    error: error.message,\n                };\n            }\n            debugHooks.onSend?.(response);\n            transport.send(response);\n            return;\n        }\n        if (message.type === \"response\") {\n            const timeout = requestTimeouts.get(message.id);\n            if (timeout != null)\n                clearTimeout(timeout);\n            const { resolve, reject } = requestListeners.get(message.id) ?? {};\n            if (!message.success)\n                reject?.(new Error(message.error));\n            else\n                resolve?.(message.payload);\n            return;\n        }\n        if (message.type === \"message\") {\n            for (const listener of wildcardMessageListeners)\n                listener(message.id, message.payload);\n            const listeners = messageListeners.get(message.id);\n            if (!listeners)\n                return;\n            for (const listener of listeners)\n                listener(message.payload);\n            return;\n        }\n        throw new Error(`Unexpected RPC message type: ${message.type}`);\n    }\n    // proxy\n    // -----\n    /**\n     * A proxy object that can be used to send requests and messages.\n     */\n    const proxy = { send: sendProxy, request: requestProxy };\n    return {\n        setTransport,\n        setRequestHandler,\n        request,\n        requestProxy,\n        send,\n        sendProxy,\n        addMessageListener,\n        removeMessageListener,\n        proxy,\n        _setDebugHooks,\n    };\n}\n",
  "import { _createRPC } from \"./rpc.js\";\n/**\n * Creates an RPC instance that can send and receive requests, responses\n * and messages.\n */\nexport function createRPC(\n/**\n * The options that will be used to configure the RPC instance.\n */\noptions) {\n    return _createRPC(options);\n}\n/**\n * Creates an RPC instance as a client. The passed schema represents\n * the remote RPC's (server) schema.\n */\nexport function createClientRPC(\n/**\n * The options that will be used to configure the RPC instance.\n */\noptions) {\n    return _createRPC(options);\n}\n/**\n * Creates an RPC instance as a server. The passed schema represents\n * this RPC's (server) schema.\n */\nexport function createServerRPC(\n/**\n * The options that will be used to configure the RPC instance.\n */\noptions) {\n    return _createRPC(options);\n}\n",
  "type WebviewEventTypes =\n  | \"did-navigate\"\n  | \"did-navigate-in-page\"\n  | \"did-commit-navigation\"\n  | \"dom-ready\";\n\ntype Rect = { x: number; y: number; width: number; height: number };\n\nconst ConfigureWebviewTags = (\n  enableWebviewTags: boolean,\n  zigRpc: (params: any) => any,\n  syncRpc: (params: any) => any\n) => {\n  if (!enableWebviewTags) {\n    return;\n  }\n\n  // todo: provide global types for <electrobun-webview> tag elements (like querySelector results etc.)\n\n  class WebviewTag extends HTMLElement {\n    // todo (yoav): come up with a better mechanism to eliminate collisions with bun created\n    // webviews\n    webviewId?: number; // = nextWebviewId++;\n\n    // rpc\n    zigRpc: any;\n    syncRpc: any;\n\n    // querySelectors for elements that you want to appear\n    // in front of the webview.\n    maskSelectors: Set<string> = new Set();\n\n    // observers\n    resizeObserver?: ResizeObserver;\n    // intersectionObserver?: IntersectionObserver;\n    // mutationObserver?: MutationObserver;\n\n    positionCheckLoop?: Timer;\n    positionCheckLoopReset?: Timer;\n\n    lastRect = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n    };\n\n    lastMasksJSON: string = \"\";\n    lastMasks: Rect[] = [];\n\n    transparent: boolean = false;\n    passthroughEnabled: boolean = false;\n    hidden: boolean = false;\n    delegateMode: boolean = false;\n    hiddenMirrorMode: boolean = false;\n    wasZeroRect: boolean = false;\n    isMirroring: boolean = false;\n\n    partition: string | null = null;\n\n    constructor() {\n      super();\n      this.zigRpc = zigRpc;\n      this.syncRpc = syncRpc;\n\n      // Give it a frame to be added to the dom and render before measuring\n      requestAnimationFrame(() => {\n        this.initWebview();\n      });\n    }\n\n    addMaskSelector(selector: string) {\n      this.maskSelectors.add(selector);\n      this.syncDimensions();\n    }\n\n    removeMaskSelector(selector: string) {\n      this.maskSelectors.delete(selector);\n      this.syncDimensions();\n    }\n\n    initWebview() {\n      const rect = this.getBoundingClientRect();\n      this.lastRect = rect;\n\n      const webviewId = this.syncRpc({\n        method: \"webviewTagInit\",\n        params: {\n          hostWebviewId: window.__electrobunWebviewId,\n          windowId: window.__electrobunWindowId,\n          url: this.src || this.getAttribute(\"src\") || null,\n          html: this.html || this.getAttribute(\"html\") || null,\n          preload: this.preload || this.getAttribute(\"preload\") || null,\n          partition: this.partition || this.getAttribute(\"partition\") || null,\n          frame: {\n            width: rect.width,\n            height: rect.height,\n            x: rect.x,\n            y: rect.y,\n          },\n        },\n      });\n\n      this.webviewId = webviewId;\n      this.id = `electrobun-webview-${this.webviewId}`;\n      // todo: replace zig -> webviewtag communication with a global instead of\n      // queryselector based on id\n      this.setAttribute(\"id\", this.id);\n    }\n\n    asyncResolvers: {\n      [id: string]: { resolve: (arg: any) => void; reject: (arg: any) => void };\n    } = {};\n\n    callAsyncJavaScript({ script }: { script: string }) {\n      return new Promise((resolve, reject) => {\n        const messageId = \"\" + Date.now() + Math.random();\n        this.asyncResolvers[messageId] = {\n          resolve,\n          reject,\n        };\n\n        this.zigRpc.request.webviewTagCallAsyncJavaScript({\n          messageId,\n          webviewId: this.webviewId,\n          hostWebviewId: window.__electrobunWebviewId,\n          script,\n        });\n      });\n    }\n\n    setCallAsyncJavaScriptResponse(messageId: string, response: any) {\n      const resolvers = this.asyncResolvers[messageId];\n      delete this.asyncResolvers[messageId];\n      try {\n        response = JSON.parse(response);\n\n        if (response.result) {\n          resolvers.resolve(response.result);\n        } else {\n          resolvers.reject(response.error);\n        }\n      } catch (e: any) {\n        resolvers.reject(e.message);\n      }\n    }\n\n    async canGoBack() {\n      const {\n        payload: { webviewTagCanGoBackResponse },\n      } = await this.zigRpc.request.webviewTagCanGoBack({ id: this.webviewId });\n      return webviewTagCanGoBackResponse;\n    }\n\n    async canGoForward() {\n      const {\n        payload: { webviewTagCanGoForwardResponse },\n      } = await this.zigRpc.request.webviewTagCanGoForward({\n        id: this.webviewId,\n      });\n      return webviewTagCanGoForwardResponse;\n    }\n\n    // propertie setters/getters. keeps them in sync with dom attributes\n    updateAttr(name: string, value: string | null) {\n      if (value) {\n        this.setAttribute(name, value);\n      } else {\n        this.removeAttribute(name);\n      }\n    }\n\n    get src() {\n      return this.getAttribute(\"src\");\n    }\n\n    set src(value) {\n      this.updateAttr(\"src\", value);\n    }\n\n    get html() {\n      return this.getAttribute(\"html\");\n    }\n\n    set html(value) {\n      this.updateAttr(\"html\", value);\n    }\n\n    get preload() {\n      return this.getAttribute(\"preload\");\n    }\n\n    set preload(value) {\n      this.updateAttr(\"preload\", value);\n    }\n\n    // Note: since <electrobun-webview> is an anchor for a native webview\n    // on osx even if we hide it, enable mouse passthrough etc. There\n    // are still events like drag events which are natively handled deep in the window manager\n    // and will be handled incorrectly. To get around this for now we need to\n    // move the webview off screen during delegate mode.\n    adjustDimensionsForHiddenMirrorMode(rect: DOMRect) {\n      if (this.hiddenMirrorMode) {\n        rect.x = 0 - rect.width;\n      }\n\n      return rect;\n    }\n\n    // Note: in the brwoser-context we can ride on the dom element's uilt in event emitter for managing custom events\n    on(event: WebviewEventTypes, listener: () => {}) {\n      this.addEventListener(event, listener);\n    }\n\n    off(event: WebviewEventTypes, listener: () => {}) {\n      this.removeEventListener(event, listener);\n    }\n\n    // This is typically called by injected js from zig\n    emit(event: WebviewEventTypes, detail: any) {\n      this.dispatchEvent(new CustomEvent(event, { detail }));\n    }\n\n    // Call this via document.querySelector('electrobun-webview').syncDimensions();\n    // That way the host can trigger an alignment with the nested webview when they\n    // know that they're chaning something in order to eliminate the lag that the\n    // catch all loop will catch\n    syncDimensions(force: boolean = false) {\n      if (!force && this.hidden) {\n        return;\n      }\n\n      const rect = this.getBoundingClientRect();\n      const { x, y, width, height } =\n        this.adjustDimensionsForHiddenMirrorMode(rect);\n      const lastRect = this.lastRect;\n\n      if (width === 0 && height === 0) {\n        if (this.wasZeroRect === false) {\n          this.wasZeroRect = true;\n          this.toggleHidden(true, true);\n        }\n        return;\n      }\n\n      const masks: Rect[] = [];\n      this.maskSelectors.forEach((selector) => {\n        const els = document.querySelectorAll(selector);\n\n        for (let i = 0; i < els.length; i++) {\n          const el = els[i];\n\n          if (el) {\n            const maskRect = el.getBoundingClientRect();\n\n            masks.push({\n              // reposition the bounding rect to be relative to the webview rect\n              // so objc can apply the mask correctly and handle the actual overlap\n              x: maskRect.x - x,\n              y: maskRect.y - y,\n              width: maskRect.width,\n              height: maskRect.height,\n            });\n          }\n        }\n      });\n\n      // store jsonStringified last masks value to compare\n      const masksJson = masks.length ? JSON.stringify(masks) : \"\";\n\n      if (\n        force ||\n        lastRect.x !== x ||\n        lastRect.y !== y ||\n        lastRect.width !== width ||\n        lastRect.height !== height ||\n        this.lastMasksJSON !== masksJson\n      ) {\n        // let it know we're still accelerating\n        this.setPositionCheckLoop(true);\n\n        this.lastRect = rect;\n        this.lastMasks = masks;\n        this.lastMasksJSON = masksJson;\n\n        this.zigRpc.send.webviewTagResize({\n          id: this.webviewId,\n          frame: {\n            width: width,\n            height: height,\n            x: x,\n            y: y,\n          },\n          masks: masksJson,\n        });\n      }\n\n      if (this.wasZeroRect) {\n        this.wasZeroRect = false;\n        this.toggleHidden(false, true);\n      }\n    }\n\n    boundSyncDimensions = () => this.syncDimensions();\n    boundForceSyncDimensions = () => this.syncDimensions(true);\n\n    setPositionCheckLoop(accelerate = false) {\n      if (this.positionCheckLoop) {\n        clearInterval(this.positionCheckLoop);\n        this.positionCheckLoop = undefined;\n      }\n\n      if (this.positionCheckLoopReset) {\n        clearTimeout(this.positionCheckLoopReset);\n        this.positionCheckLoopReset = undefined;\n      }\n\n      const delay = accelerate ? 0 : 300;\n\n      if (accelerate) {\n        this.positionCheckLoopReset = setTimeout(() => {\n          this.setPositionCheckLoop(false);\n        }, 2000);\n      }\n      // Note: Since there's not catch all way to listen for x/y changes\n      // we have a 400ms interval to check\n      // on m1 max this 400ms interval for one nested webview\n      // only uses around 0.1% cpu\n\n      // Note: We also listen for resize events and changes to\n      // certain properties to get reactive repositioning for\n      // many cases.\n\n      // todo: consider having an option to disable this and let user\n      // trigger position sync for high performance cases (like\n      // a browser with a hundred tabs)\n      this.positionCheckLoop = setInterval(() => this.syncDimensions(), delay);\n    }\n\n    connectedCallback() {\n      this.setPositionCheckLoop();\n\n      this.resizeObserver = new ResizeObserver(() => {\n        this.syncDimensions();\n      });\n      // Note: In objc the webview is positioned in the window from the bottom-left corner\n      // the html anchor is positioned in the webview from the top-left corner\n      // In those cases the getBoundingClientRect() will return the same value, but\n      // we still need to send it to objc to calculate from its bottom left position\n      // otherwise it'll move around unexpectedly.\n      window.addEventListener(\"resize\", this.boundForceSyncDimensions);\n      window.addEventListener(\"scroll\", this.boundSyncDimensions);\n\n      // todo: For chromium webviews (windows native or chromium bundled)\n      // should be able to use performanceObservers on layout-shift to\n      // call syncDimensions more reactively\n    }\n\n    disconnectedCallback() {\n      // removed from the dom\n      clearInterval(this.positionCheckLoop);\n\n      this.resizeObserver?.disconnect();\n      // this.intersectionObserver?.disconnect();\n      // this.mutationObserver?.disconnect();\n      window.removeEventListener(\"resize\", this.boundForceSyncDimensions);\n      window.removeEventListener(\"scroll\", this.boundSyncDimensions);\n      this.zigRpc.send.webviewTagRemove({ id: this.webviewId });\n    }\n\n    static get observedAttributes() {\n      // TODO: support html, preload, and other stuff here\n      return [\"src\", \"html\", \"preload\", \"class\", \"style\"];\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (name === \"src\" && oldValue !== newValue) {\n        this.updateIFrameSrc(newValue);\n      } else if (name === \"html\" && oldValue !== newValue) {\n        this.updateIFrameHtml(newValue);\n      } else if (name === \"preload\" && oldValue !== newValue) {\n        this.updateIFramePreload(newValue);\n      } else {\n        this.syncDimensions();\n      }\n    }\n\n    updateIFrameSrc(src: string) {\n      if (!this.webviewId) {\n        return;\n      }\n      this.zigRpc.send.webviewTagUpdateSrc({\n        id: this.webviewId,\n        url: src,\n      });\n    }\n\n    updateIFrameHtml(html: string) {\n      if (!this.webviewId) {\n        return;\n      }\n      this.zigRpc.send.webviewTagUpdateHtml({\n        id: this.webviewId,\n        html,\n      });\n    }\n\n    updateIFramePreload(preload: string) {\n      if (!this.webviewId) {\n        return;\n      }\n      this.zigRpc.send.webviewTagUpdatePreload({\n        id: this.webviewId,\n        preload,\n      });\n    }\n\n    goBack() {\n      this.zigRpc.send.webviewTagGoBack({ id: this.webviewId });\n    }\n\n    goForward() {\n      this.zigRpc.send.webviewTagGoForward({ id: this.webviewId });\n    }\n\n    reload() {\n      this.zigRpc.send.webviewTagReload({ id: this.webviewId });\n    }\n    loadURL(url: string) {\n      this.setAttribute(\"src\", url);\n      this.zigRpc.send.webviewTagUpdateSrc({\n        id: this.webviewId,\n        url,\n      });\n    }\n    // Note: you can set an interval and do this 60 times a second and it's pretty smooth\n    // but it uses quite a bit of cpu\n    // todo: change this to \"mirror to dom\" or something\n    syncScreenshot(callback?: () => void) {\n      const cacheBustString = `?${Date.now()}`;\n      const url = `views://screenshot/${this.webviewId}${cacheBustString}`;\n      const img = new Image();\n      img.src = url;\n      img.onload = () => {\n        this.style.backgroundImage = `url(${url})`;\n        if (callback) {\n          // We've preloaded the image, but we still want to give it a chance to render\n          // after setting the background style. give it quite a bit longer than a rafr\n          setTimeout(callback, 100);\n        }\n      };\n    }\n\n    DEFAULT_FRAME_RATE = Math.round(1000 / 30); // 30fps\n    streamScreenInterval?: Timer;\n\n    // NOTE: This is very cpu intensive, Prefer startMirroring where possible\n    startMirroringToDom(frameRate: number = this.DEFAULT_FRAME_RATE) {\n      if (this.streamScreenInterval) {\n        clearInterval(this.streamScreenInterval);\n      }\n\n      this.streamScreenInterval = setInterval(() => {\n        this.syncScreenshot();\n      }, frameRate);\n    }\n\n    stopMirroringToDom() {\n      if (this.streamScreenInterval) {\n        clearInterval(this.streamScreenInterval);\n        this.streamScreenInterval = undefined;\n      }\n    }\n\n    startMirroring() {\n      // TEMP: mirroring now happens automatically in objc\n      // when the mouse moves. I'm leaving this here for now\n      // because I suspect there may still be use cases to\n      // toggle it from the dom outside of the mouse moving.\n      return;\n      if (this.isMirroring === false) {\n        this.isMirroring = true;\n        this.zigRpc.send.webviewTagToggleMirroring({\n          id: this.webviewId,\n          enable: true,\n        });\n      }\n    }\n\n    stopMirroring() {\n      return;\n      if (this.isMirroring === true) {\n        this.isMirroring = false;\n        this.zigRpc.send.webviewTagToggleMirroring({\n          id: this.webviewId,\n          enable: false,\n        });\n      }\n    }\n\n    clearScreenImage() {\n      this.style.backgroundImage = \"\";\n    }\n\n    tryClearScreenImage() {\n      if (\n        !this.transparent &&\n        !this.hiddenMirrorMode &&\n        !this.delegateMode &&\n        !this.hidden\n      ) {\n        this.clearScreenImage();\n      }\n    }\n    // This sets the native webview hovering over the dom to be transparent\n    toggleTransparent(transparent?: boolean, bypassState?: boolean) {\n      if (!bypassState) {\n        if (typeof transparent === \"undefined\") {\n          this.transparent = !this.transparent;\n        } else {\n          this.transparent = transparent;\n        }\n      }\n\n      if (!this.transparent && !transparent) {\n        this.tryClearScreenImage();\n      }\n\n      this.zigRpc.send.webviewTagSetTransparent({\n        id: this.webviewId,\n        transparent: this.transparent || Boolean(transparent),\n      });\n    }\n    togglePassthrough(enablePassthrough?: boolean, bypassState?: boolean) {\n      if (!bypassState) {\n        if (typeof enablePassthrough === \"undefined\") {\n          this.passthroughEnabled = !this.passthroughEnabled;\n        } else {\n          this.passthroughEnabled = enablePassthrough;\n        }\n      }\n\n      this.zigRpc.send.webviewTagSetPassthrough({\n        id: this.webviewId,\n        enablePassthrough:\n          this.passthroughEnabled || Boolean(enablePassthrough),\n      });\n    }\n\n    toggleHidden(hidden?: boolean, bypassState?: boolean) {\n      if (!bypassState) {\n        if (typeof hidden === \"undefined\") {\n          this.hidden = !this.hidden;\n        } else {\n          this.hidden = hidden;\n        }\n      }\n\n      this.zigRpc.send.webviewTagSetHidden({\n        id: this.webviewId,\n        hidden: this.hidden || Boolean(hidden),\n      });\n    }\n\n    // note: delegateMode and hiddenMirrorMode are experimental\n    // ideally delegate mode would move the webview off screen\n    // and delegate mouse and keyboard events to the webview while\n    // streaming the screen so it can be fully layered in the dom\n    // and fully interactive.\n    toggleDelegateMode(delegateMode?: boolean) {\n      const _newDelegateMode =\n        typeof delegateMode === \"undefined\" ? !this.delegateMode : delegateMode;\n\n      if (_newDelegateMode) {\n        this.syncScreenshot(() => {\n          this.delegateMode = true;\n          this.toggleTransparent(true, true);\n          this.startMirroringToDom();\n        });\n      } else {\n        this.delegateMode = false;\n        this.stopMirroringToDom();\n        this.toggleTransparent(this.transparent);\n        this.tryClearScreenImage();\n      }\n    }\n\n    // While hiddenMirroMode would be similar to delegate mode but non-interactive\n    // This is used while scrolling or resizing the <electrobun-webviewtag> to\n    // make it smoother (scrolls with the dom) but disables interaction so that\n    // during the scroll we don't need to worry about the webview being misaligned\n    // with the mirror and accidentlly clicking on the wrong thing.\n    toggleHiddenMirrorMode(force: boolean) {\n      const enable =\n        typeof force === \"undefined\" ? !this.hiddenMirrorMode : force;\n\n      if (enable === true) {\n        this.syncScreenshot(() => {\n          this.hiddenMirrorMode = true;\n          this.toggleHidden(true, true);\n          this.togglePassthrough(true, true);\n          this.startMirroringToDom();\n        });\n      } else {\n        this.stopMirroringToDom();\n        this.toggleHidden(this.hidden);\n        this.togglePassthrough(this.passthroughEnabled);\n        this.tryClearScreenImage();\n        this.hiddenMirrorMode = false;\n      }\n    }\n  }\n\n  customElements.define(\"electrobun-webview\", WebviewTag);\n\n  insertWebviewTagNormalizationStyles();\n};\n\n// Give <electrobun-webview>s some default styles that can\n// be easily overridden in the host document\nconst insertWebviewTagNormalizationStyles = () => {\n  var style = document.createElement(\"style\");\n  style.type = \"text/css\";\n\n  var css = `\nelectrobun-webview {\n    display: block;\n    width: 800px;\n    height: 300px;\n    background: #fff;\n    background-repeat: no-repeat!important;   \n    overflow: hidden; \n}\n`;\n\n  style.appendChild(document.createTextNode(css));\n\n  var head = document.getElementsByTagName(\"head\")[0];\n  if (!head) {\n    return;\n  }\n\n  if (head.firstChild) {\n    head.insertBefore(style, head.firstChild);\n  } else {\n    head.appendChild(style);\n  }\n};\n\nexport { ConfigureWebviewTags };\n",
  "export const isAppRegionDrag = (e: MouseEvent) => {\n  return e.target?.classList.contains(\"electrobun-webkit-app-region-drag\");\n};\n",
  "import {\n  type RPCSchema,\n  type RPCRequestHandler,\n  type RPCOptions,\n  type RPCMessageHandlerFn,\n  type WildcardRPCMessageHandlerFn,\n  type RPCTransport,\n  createRPC,\n} from \"rpc-anywhere\";\nimport { ConfigureWebviewTags } from \"./webviewtag\";\n// todo: should this just be injected as a preload script?\nimport { isAppRegionDrag } from \"./stylesAndElements\";\nimport type { BuiltinBunToWebviewSchema } from \"./builtinrpcSchema\";\n\ninterface ElectrobunWebviewRPCSChema {\n  bun: RPCSchema;\n  webview: RPCSchema;\n}\n\nconst WEBVIEW_ID = window.__electrobunWebviewId;\n\n// todo (yoav): move this stuff to browser/rpc/webview.ts\ntype ZigWebviewHandlers = RPCSchema<{\n  requests: {\n    webviewTagCallAsyncJavaScript: {\n      params: {\n        messageId: string;\n        webviewId: number;\n        hostWebviewId: number;\n        script: string;\n      };\n      response: void;\n    };\n  };\n}>;\n\ntype WebviewTagHandlers = RPCSchema<{\n  requests: {};\n  messages: {\n    webviewTagResize: {\n      id: number;\n      frame: {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n      };\n      masks: string;\n    };\n    webviewTagUpdateSrc: {\n      id: number;\n      url: string;\n    };\n    webviewTagGoBack: {\n      id: number;\n    };\n    webviewTagGoForward: {\n      id: number;\n    };\n    webviewTagReload: {\n      id: number;\n    };\n    webviewTagRemove: {\n      id: number;\n    };\n    startWindowMove: {\n      id: number;\n    };\n    stopWindowMove: {\n      id: number;\n    };\n    moveWindowBy: {\n      id: number;\n      x: number;\n      y: number;\n    };\n    webviewTagSetTransparent: {\n      id: number;\n      transparent: boolean;\n    };\n    webviewTagToggleMirroring: {\n      id: number;\n      enable: boolean;\n    };\n    webviewTagSetPassthrough: {\n      id: number;\n      enablePassthrough: boolean;\n    };\n    webviewTagSetHidden: {\n      id: number;\n      hidden: boolean;\n    };\n  };\n}>;\n\nclass Electroview<T> {\n  // user's custom rpc browser <-> bun\n  rpc?: T;\n  rpcHandler?: (msg: any) => void;\n  // electrobun rpc browser <-> zig\n  zigRpc?: any;\n  zigRpcHandler?: (msg: any) => void;\n  // give it a default function\n  syncRpc: (params: any) => any = () => {\n    console.log(\"syncRpc not initialized\");\n  };\n\n  constructor(config: { rpc: T }) {\n    this.rpc = config.rpc;\n    this.init();\n  }\n\n  init() {\n    // todo (yoav): should init webviewTag by default when src is local\n    // and have a setting that forces it enabled or disabled\n    this.initZigRpc();\n    // Note:\n    // syncRPC messages doesn't need to be defined since there's no need for sync 1-way message\n    // just use non-blocking async rpc for that, we just need sync requests\n    // We don't need request ids either since we're not receiving the response on a different pipe\n    if (true) {\n      // TODO: define sync requests on schema (separate from async reqeusts and messages)\n      this.syncRpc = (msg: { method: string; params: any }) => {\n        try {\n          const messageString = JSON.stringify(msg);\n          return this.bunBridgeSync(messageString);\n        } catch (error) {\n          console.error(\n            \"bun: failed to serialize message to webview syncRpc\",\n            error\n          );\n        }\n      };\n    }\n    ConfigureWebviewTags(true, this.zigRpc, this.syncRpc);\n\n    this.initElectrobunListeners();\n\n    window.__electrobun = {\n      receiveMessageFromBun: this.receiveMessageFromBun.bind(this),\n      receiveMessageFromZig: this.receiveMessageFromZig.bind(this),\n    };\n\n    if (this.rpc) {\n      this.rpc.setTransport(this.createTransport());\n    }\n  }\n\n  initZigRpc() {\n    this.zigRpc = createRPC<WebviewTagHandlers, ZigWebviewHandlers>({\n      transport: this.createZigTransport(),\n      // requestHandler: {\n\n      // },\n      maxRequestTime: 1000,\n    });\n  }\n\n  // This will be attached to the global object, zig can rpc reply by executingJavascript\n  // of that global reference to the function\n  receiveMessageFromZig(msg: any) {\n    if (this.zigRpcHandler) {\n      this.zigRpcHandler(msg);\n    }\n  }\n\n  // TODO: implement proper rpc-anywhere style rpc here\n  // todo: this is duplicated in webviewtag.ts and should be DRYed up\n  sendToZig(message: {}) {\n    window.webkit.messageHandlers.webviewTagBridge.postMessage(\n      JSON.stringify(message)\n    );\n  }\n\n  initElectrobunListeners() {\n    document.addEventListener(\"mousedown\", (e) => {\n      if (isAppRegionDrag(e)) {\n        this.zigRpc?.send.startWindowMove({ id: WEBVIEW_ID });\n      }\n    });\n\n    document.addEventListener(\"mouseup\", (e) => {\n      if (isAppRegionDrag(e)) {\n        this.zigRpc?.send.stopWindowMove({ id: WEBVIEW_ID });\n      }\n    });\n  }\n\n  createTransport() {\n    const that = this;\n    return {\n      send(message) {\n        try {\n          const messageString = JSON.stringify(message);\n          that.bunBridge(messageString);\n        } catch (error) {\n          console.error(\"bun: failed to serialize message to webview\", error);\n        }\n      },\n      registerHandler(handler) {\n        that.rpcHandler = handler;\n      },\n    };\n  }\n\n  createZigTransport(): RPCTransport {\n    const that = this;\n    return {\n      send(message) {\n        window.webkit.messageHandlers.webviewTagBridge.postMessage(\n          JSON.stringify(message)\n        );\n      },\n      registerHandler(handler) {\n        that.zigRpcHandler = handler;\n        // webview tag doesn't handle any messages from zig just yet\n      },\n    };\n  }\n\n  // call any of your bun syncrpc methods in a way that appears synchronous from the browser context\n  bunBridgeSync(msg: string) {\n    var xhr = new XMLHttpRequest();\n    // Note: setting false here makes the xhr request blocking. This completely\n    // blocks the main thread which is terrible. You can use this safely from a webworker.\n    // There are also cases where exposing bun sync apis (eg: existsSync) is useful especially\n    // on a first pass when migrating from Electron to Electrobun.\n    // This mechanism is designed to make any rpc call over the bridge into a sync blocking call\n    // from the browser context while bun asynchronously replies. Use it sparingly from the main thread.\n    xhr.open(\"POST\", \"views://syncrpc\", false); // Synchronous call\n    xhr.send(msg);\n    if (!xhr.responseText) {\n      return xhr.responseText;\n    }\n\n    try {\n      return JSON.parse(xhr.responseText);\n    } catch {\n      return xhr.responseText;\n    }\n  }\n\n  bunBridge(msg: string) {\n    // Note: messageHandlers seem to freeze when sending large messages\n    // but xhr to views://rpc can run into CORS issues on non views://\n    // loaded content (eg: when writing extensions/preload scripts for\n    // remote content).\n\n    // Since most messages--especially those on remote content, are small\n    // we can solve most use cases by having a fallback to xhr for\n    // large messages\n\n    // TEMP: disable the fallback for now. for some reason suddenly can't\n    // repro now that other places are chunking messages and laptop restart\n    if (true || msg.length < 8 * 1024) {\n      window.webkit.messageHandlers.bunBridge.postMessage(msg);\n    } else {\n      var xhr = new XMLHttpRequest();\n\n      // Note: we're only using synchronouse http on this async\n      // call to get around CORS for now\n      // Note: DO NOT use postMessage handlers since it\n      // freezes the process when sending lots of large messages\n\n      xhr.open(\"POST\", \"views://rpc\", false); // sychronous call\n      xhr.send(msg);\n    }\n  }\n\n  receiveMessageFromBun(msg) {\n    // NOTE: in the webview messages are passed by executing ElectrobunView.receiveMessageFromBun(object)\n    // so they're already parsed into an object here\n    if (this.rpcHandler) {\n      this.rpcHandler(msg);\n    }\n  }\n  // todo (yoav): This is mostly just the reverse of the one in BrowserView.ts on the bun side. Should DRY this up.\n  static defineRPC<\n    Schema extends ElectrobunWebviewRPCSChema,\n    BunSchema extends RPCSchema = Schema[\"bun\"],\n    WebviewSchema extends RPCSchema = Schema[\"webview\"]\n  >(config: {\n    maxRequestTime?: number;\n    handlers: {\n      requests?: RPCRequestHandler<WebviewSchema[\"requests\"]>;\n      messages?: {\n        [key in keyof WebviewSchema[\"messages\"]]: RPCMessageHandlerFn<\n          WebviewSchema[\"messages\"],\n          key\n        >;\n      } & {\n        \"*\"?: WildcardRPCMessageHandlerFn<WebviewSchema[\"messages\"]>;\n      };\n    };\n  }) {\n    // Note: RPC Anywhere requires defining the requests that a schema handles and the messages that a schema sends.\n    // eg: BunSchema {\n    //   requests: // ... requests bun handles, sent by webview\n    //   messages: // ... messages bun sends, handled by webview\n    // }\n    // In some generlized contexts that makes sense,\n    // In the Electrobun context it can feel a bit counter-intuitive so we swap this around a bit. In Electrobun, the\n    // webview and bun are known endpoints so we simplify schema definitions by combining them.\n    // Schema {\n    //   bun: BunSchema {\n    //      requests: // ... requests bun sends, handled by webview,\n    //      messages: // ... messages bun sends, handled by webview\n    //    },\n    //   webview: WebviewSchema {\n    //      requests: // ... requests webview sends, handled by bun,\n    //      messages: // ... messages webview sends, handled by bun\n    //    },\n    // }\n    // electrobun also treats messages as \"requests that we don't wait for to complete\", and normalizes specifying the\n    // handlers for them alongside request handlers.\n\n    const builtinHandlers: {\n      requests: RPCRequestHandler<BuiltinBunToWebviewSchema[\"requests\"]>;\n    } = {\n      requests: {\n        evaluateJavascriptWithResponse: ({ script }) => {\n          return new Promise((resolve) => {\n            try {\n              const resultFunction = new Function(script);\n              const result = resultFunction();\n\n              if (result instanceof Promise) {\n                result\n                  .then((resolvedResult) => {\n                    resolve(resolvedResult);\n                  })\n                  .catch((error) => {\n                    console.error(\"bun: async script execution failed\", error);\n                    resolve(String(error));\n                  });\n              } else {\n                resolve(result);\n              }\n            } catch (error) {\n              console.error(\"bun: failed to eval script\", error);\n              resolve(String(error));\n            }\n          });\n        },\n      },\n    };\n\n    type mixedWebviewSchema = {\n      requests: BunSchema[\"requests\"];\n      messages: WebviewSchema[\"messages\"];\n    };\n\n    type mixedBunSchema = {\n      requests: WebviewSchema[\"requests\"] &\n        BuiltinBunToWebviewSchema[\"requests\"];\n      messages: BunSchema[\"messages\"];\n    };\n\n    const rpcOptions = {\n      maxRequestTime: config.maxRequestTime,\n      requestHandler: {\n        ...config.handlers.requests,\n        ...builtinHandlers.requests,\n      },\n      transport: {\n        // Note: RPC Anywhere will throw if you try add a message listener if transport.registerHandler is falsey\n        registerHandler: () => {},\n      },\n    } as RPCOptions<mixedBunSchema, mixedWebviewSchema>;\n\n    const rpc = createRPC<mixedBunSchema, mixedWebviewSchema>(rpcOptions);\n\n    const messageHandlers = config.handlers.messages;\n    if (messageHandlers) {\n      // note: this can only be done once there is a transport\n      // @ts-ignore - this is due to all the schema mixing we're doing, fine to ignore\n      // while types in here are borked, they resolve correctly/bubble up to the defineRPC call site.\n      rpc.addMessageListener(\n        \"*\",\n        (messageName: keyof WebviewSchema[\"messages\"], payload) => {\n          const globalHandler = messageHandlers[\"*\"];\n          if (globalHandler) {\n            globalHandler(messageName, payload);\n          }\n\n          const messageHandler = messageHandlers[messageName];\n          if (messageHandler) {\n            messageHandler(payload);\n          }\n        }\n      );\n    }\n\n    return rpc;\n  }\n}\n\nexport { type RPCSchema, createRPC, Electroview };\n\nconst Electrobun = {\n  Electroview,\n};\n\nexport default Electrobun;\n",
  "import {\n  type RPCSchema,\n  type RPCRequestHandler,\n  type RPCOptions,\n  type RPCMessageHandlerFn,\n  type WildcardRPCMessageHandlerFn,\n  type RPCTransport,\n  createRPC,\n} from \"rpc-anywhere\";\nimport { ConfigureWebviewTags } from \"./webviewtag\";\n// todo: should this just be injected as a preload script?\nimport { isAppRegionDrag } from \"./stylesAndElements\";\nimport type { BuiltinBunToWebviewSchema } from \"./builtinrpcSchema\";\n\ninterface ElectrobunWebviewRPCSChema {\n  bun: RPCSchema;\n  webview: RPCSchema;\n}\n\nconst WEBVIEW_ID = window.__electrobunWebviewId;\n\n// todo (yoav): move this stuff to browser/rpc/webview.ts\ntype ZigWebviewHandlers = RPCSchema<{\n  requests: {\n    webviewTagCallAsyncJavaScript: {\n      params: {\n        messageId: string;\n        webviewId: number;\n        hostWebviewId: number;\n        script: string;\n      };\n      response: void;\n    };\n  };\n}>;\n\ntype WebviewTagHandlers = RPCSchema<{\n  requests: {};\n  messages: {\n    webviewTagResize: {\n      id: number;\n      frame: {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n      };\n      masks: string;\n    };\n    webviewTagUpdateSrc: {\n      id: number;\n      url: string;\n    };\n    webviewTagGoBack: {\n      id: number;\n    };\n    webviewTagGoForward: {\n      id: number;\n    };\n    webviewTagReload: {\n      id: number;\n    };\n    webviewTagRemove: {\n      id: number;\n    };\n    startWindowMove: {\n      id: number;\n    };\n    stopWindowMove: {\n      id: number;\n    };\n    moveWindowBy: {\n      id: number;\n      x: number;\n      y: number;\n    };\n    webviewTagSetTransparent: {\n      id: number;\n      transparent: boolean;\n    };\n    webviewTagToggleMirroring: {\n      id: number;\n      enable: boolean;\n    };\n    webviewTagSetPassthrough: {\n      id: number;\n      enablePassthrough: boolean;\n    };\n    webviewTagSetHidden: {\n      id: number;\n      hidden: boolean;\n    };\n  };\n}>;\n\nclass Electroview<T> {\n  // user's custom rpc browser <-> bun\n  rpc?: T;\n  rpcHandler?: (msg: any) => void;\n  // electrobun rpc browser <-> zig\n  zigRpc?: any;\n  zigRpcHandler?: (msg: any) => void;\n  // give it a default function\n  syncRpc: (params: any) => any = () => {\n    console.log(\"syncRpc not initialized\");\n  };\n\n  constructor(config: { rpc: T }) {\n    this.rpc = config.rpc;\n    this.init();\n  }\n\n  init() {\n    // todo (yoav): should init webviewTag by default when src is local\n    // and have a setting that forces it enabled or disabled\n    this.initZigRpc();\n    // Note:\n    // syncRPC messages doesn't need to be defined since there's no need for sync 1-way message\n    // just use non-blocking async rpc for that, we just need sync requests\n    // We don't need request ids either since we're not receiving the response on a different pipe\n    if (true) {\n      // TODO: define sync requests on schema (separate from async reqeusts and messages)\n      this.syncRpc = (msg: { method: string; params: any }) => {\n        try {\n          const messageString = JSON.stringify(msg);\n          return this.bunBridgeSync(messageString);\n        } catch (error) {\n          console.error(\n            \"bun: failed to serialize message to webview syncRpc\",\n            error\n          );\n        }\n      };\n    }\n    ConfigureWebviewTags(true, this.zigRpc, this.syncRpc);\n\n    this.initElectrobunListeners();\n\n    window.__electrobun = {\n      receiveMessageFromBun: this.receiveMessageFromBun.bind(this),\n      receiveMessageFromZig: this.receiveMessageFromZig.bind(this),\n    };\n\n    if (this.rpc) {\n      this.rpc.setTransport(this.createTransport());\n    }\n  }\n\n  initZigRpc() {\n    this.zigRpc = createRPC<WebviewTagHandlers, ZigWebviewHandlers>({\n      transport: this.createZigTransport(),\n      // requestHandler: {\n\n      // },\n      maxRequestTime: 1000,\n    });\n  }\n\n  // This will be attached to the global object, zig can rpc reply by executingJavascript\n  // of that global reference to the function\n  receiveMessageFromZig(msg: any) {\n    if (this.zigRpcHandler) {\n      this.zigRpcHandler(msg);\n    }\n  }\n\n  // TODO: implement proper rpc-anywhere style rpc here\n  // todo: this is duplicated in webviewtag.ts and should be DRYed up\n  sendToZig(message: {}) {\n    window.webkit.messageHandlers.webviewTagBridge.postMessage(\n      JSON.stringify(message)\n    );\n  }\n\n  initElectrobunListeners() {\n    document.addEventListener(\"mousedown\", (e) => {\n      if (isAppRegionDrag(e)) {\n        this.zigRpc?.send.startWindowMove({ id: WEBVIEW_ID });\n      }\n    });\n\n    document.addEventListener(\"mouseup\", (e) => {\n      if (isAppRegionDrag(e)) {\n        this.zigRpc?.send.stopWindowMove({ id: WEBVIEW_ID });\n      }\n    });\n  }\n\n  createTransport() {\n    const that = this;\n    return {\n      send(message) {\n        try {\n          const messageString = JSON.stringify(message);\n          that.bunBridge(messageString);\n        } catch (error) {\n          console.error(\"bun: failed to serialize message to webview\", error);\n        }\n      },\n      registerHandler(handler) {\n        that.rpcHandler = handler;\n      },\n    };\n  }\n\n  createZigTransport(): RPCTransport {\n    const that = this;\n    return {\n      send(message) {\n        window.webkit.messageHandlers.webviewTagBridge.postMessage(\n          JSON.stringify(message)\n        );\n      },\n      registerHandler(handler) {\n        that.zigRpcHandler = handler;\n        // webview tag doesn't handle any messages from zig just yet\n      },\n    };\n  }\n\n  // call any of your bun syncrpc methods in a way that appears synchronous from the browser context\n  bunBridgeSync(msg: string) {\n    var xhr = new XMLHttpRequest();\n    // Note: setting false here makes the xhr request blocking. This completely\n    // blocks the main thread which is terrible. You can use this safely from a webworker.\n    // There are also cases where exposing bun sync apis (eg: existsSync) is useful especially\n    // on a first pass when migrating from Electron to Electrobun.\n    // This mechanism is designed to make any rpc call over the bridge into a sync blocking call\n    // from the browser context while bun asynchronously replies. Use it sparingly from the main thread.\n    xhr.open(\"POST\", \"views://syncrpc\", false); // Synchronous call\n    xhr.send(msg);\n    if (!xhr.responseText) {\n      return xhr.responseText;\n    }\n\n    try {\n      return JSON.parse(xhr.responseText);\n    } catch {\n      return xhr.responseText;\n    }\n  }\n\n  bunBridge(msg: string) {\n    // Note: messageHandlers seem to freeze when sending large messages\n    // but xhr to views://rpc can run into CORS issues on non views://\n    // loaded content (eg: when writing extensions/preload scripts for\n    // remote content).\n\n    // Since most messages--especially those on remote content, are small\n    // we can solve most use cases by having a fallback to xhr for\n    // large messages\n\n    // TEMP: disable the fallback for now. for some reason suddenly can't\n    // repro now that other places are chunking messages and laptop restart\n    if (true || msg.length < 8 * 1024) {\n      window.webkit.messageHandlers.bunBridge.postMessage(msg);\n    } else {\n      var xhr = new XMLHttpRequest();\n\n      // Note: we're only using synchronouse http on this async\n      // call to get around CORS for now\n      // Note: DO NOT use postMessage handlers since it\n      // freezes the process when sending lots of large messages\n\n      xhr.open(\"POST\", \"views://rpc\", false); // sychronous call\n      xhr.send(msg);\n    }\n  }\n\n  receiveMessageFromBun(msg) {\n    // NOTE: in the webview messages are passed by executing ElectrobunView.receiveMessageFromBun(object)\n    // so they're already parsed into an object here\n    if (this.rpcHandler) {\n      this.rpcHandler(msg);\n    }\n  }\n  // todo (yoav): This is mostly just the reverse of the one in BrowserView.ts on the bun side. Should DRY this up.\n  static defineRPC<\n    Schema extends ElectrobunWebviewRPCSChema,\n    BunSchema extends RPCSchema = Schema[\"bun\"],\n    WebviewSchema extends RPCSchema = Schema[\"webview\"]\n  >(config: {\n    maxRequestTime?: number;\n    handlers: {\n      requests?: RPCRequestHandler<WebviewSchema[\"requests\"]>;\n      messages?: {\n        [key in keyof WebviewSchema[\"messages\"]]: RPCMessageHandlerFn<\n          WebviewSchema[\"messages\"],\n          key\n        >;\n      } & {\n        \"*\"?: WildcardRPCMessageHandlerFn<WebviewSchema[\"messages\"]>;\n      };\n    };\n  }) {\n    // Note: RPC Anywhere requires defining the requests that a schema handles and the messages that a schema sends.\n    // eg: BunSchema {\n    //   requests: // ... requests bun handles, sent by webview\n    //   messages: // ... messages bun sends, handled by webview\n    // }\n    // In some generlized contexts that makes sense,\n    // In the Electrobun context it can feel a bit counter-intuitive so we swap this around a bit. In Electrobun, the\n    // webview and bun are known endpoints so we simplify schema definitions by combining them.\n    // Schema {\n    //   bun: BunSchema {\n    //      requests: // ... requests bun sends, handled by webview,\n    //      messages: // ... messages bun sends, handled by webview\n    //    },\n    //   webview: WebviewSchema {\n    //      requests: // ... requests webview sends, handled by bun,\n    //      messages: // ... messages webview sends, handled by bun\n    //    },\n    // }\n    // electrobun also treats messages as \"requests that we don't wait for to complete\", and normalizes specifying the\n    // handlers for them alongside request handlers.\n\n    const builtinHandlers: {\n      requests: RPCRequestHandler<BuiltinBunToWebviewSchema[\"requests\"]>;\n    } = {\n      requests: {\n        evaluateJavascriptWithResponse: ({ script }) => {\n          return new Promise((resolve) => {\n            try {\n              const resultFunction = new Function(script);\n              const result = resultFunction();\n\n              if (result instanceof Promise) {\n                result\n                  .then((resolvedResult) => {\n                    resolve(resolvedResult);\n                  })\n                  .catch((error) => {\n                    console.error(\"bun: async script execution failed\", error);\n                    resolve(String(error));\n                  });\n              } else {\n                resolve(result);\n              }\n            } catch (error) {\n              console.error(\"bun: failed to eval script\", error);\n              resolve(String(error));\n            }\n          });\n        },\n      },\n    };\n\n    type mixedWebviewSchema = {\n      requests: BunSchema[\"requests\"];\n      messages: WebviewSchema[\"messages\"];\n    };\n\n    type mixedBunSchema = {\n      requests: WebviewSchema[\"requests\"] &\n        BuiltinBunToWebviewSchema[\"requests\"];\n      messages: BunSchema[\"messages\"];\n    };\n\n    const rpcOptions = {\n      maxRequestTime: config.maxRequestTime,\n      requestHandler: {\n        ...config.handlers.requests,\n        ...builtinHandlers.requests,\n      },\n      transport: {\n        // Note: RPC Anywhere will throw if you try add a message listener if transport.registerHandler is falsey\n        registerHandler: () => {},\n      },\n    } as RPCOptions<mixedBunSchema, mixedWebviewSchema>;\n\n    const rpc = createRPC<mixedBunSchema, mixedWebviewSchema>(rpcOptions);\n\n    const messageHandlers = config.handlers.messages;\n    if (messageHandlers) {\n      // note: this can only be done once there is a transport\n      // @ts-ignore - this is due to all the schema mixing we're doing, fine to ignore\n      // while types in here are borked, they resolve correctly/bubble up to the defineRPC call site.\n      rpc.addMessageListener(\n        \"*\",\n        (messageName: keyof WebviewSchema[\"messages\"], payload) => {\n          const globalHandler = messageHandlers[\"*\"];\n          if (globalHandler) {\n            globalHandler(messageName, payload);\n          }\n\n          const messageHandler = messageHandlers[messageName];\n          if (messageHandler) {\n            messageHandler(payload);\n          }\n        }\n      );\n    }\n\n    return rpc;\n  }\n}\n\nexport { type RPCSchema, createRPC, Electroview };\n\nconst Electrobun = {\n  Electroview,\n};\n\nexport default Electrobun;\n"
  ],
  "mappings": "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",
  "debugId": "5A7994858FFC99B964756e2164756e21",
  "names": []
}